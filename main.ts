

animation#!/usr/bin / env node
/**
 * Zellschwarm Code-Raum — ParallelUniverse Simulator (Node.js)
 * - Agents produce "Thoughts" (streams)
 * - InMemoryBus distributes thoughts to subscribers
 * - Monitor aggregates and emits metrics via WebSocket
 * - HTTP API accepts tasks (NFC controller / human input)
 *
 * Usage:
 *   npm install
 *   node index.js
 *
 * Requirements: Node 18+
 *
 * Safety: No weapon functionality. This is a creative simulation environment.
 */

import express from "express";
import bodyParser from "body-parser";
import { WebSocketServer } from "ws";
import { nanoid } from "nanoid";
import fs from "fs";
import path from "path";
import os from "os";

const RESULTS_DIR = path.resolve(process.cwd(), "results");
if (!fs.existsSync(RESULTS_DIR)) fs.mkdirSync(RESULTS_DIR, { recursive: true });

/* ---------------------------
   Basic datatypes / utils
   --------------------------- */
class Thought {
    constructor(id, topic, intensity, payload = {}) {
        this.id = id;
        this.topic = topic;
        this.intensity = intensity;
        this.payload = payload;
        this.ts = Date.now();
    }
}

function randChoice(arr) {
    return arr[Math.floor(Math.random() * arr.length)];
}

function nowISO() {
    return new Date().toISOString();
}

/* ---------------------------
   InMemoryBus
   --------------------------- */
class InMemoryBus {
    constructor() {
        this.subscribers = new Map(); // id -> callback
    }
    subscribe(cb) {
        const id = nanoid();
        this.subscribers.set(id, cb);
        return () => this.subscribers.delete(id);
    }
    async publish(agentId, thought) {
        // distribute to subscribers asynchronously but non-blocking
        for (const cb of this.subscribers.values()) {
            try {
                // fire-and-forget, but do not block the publisher
                setImmediate(() => {
                    try { cb(agentId, thought); } catch (e) { /* ignore */ }
                });
            } catch (e) {
                // swallow
            }
        }
    }
}

/* ---------------------------
   Agent (cell) - produces thoughts
   --------------------------- */
class Agent {
    constructor(aid, bus, options = {}) {
        this.aid = aid;
        this.bus = bus;
        this.running = false;
        this.counter = 0;
        this.topics = options.topics || ["econ", "env", "traffic", "meta", "art"];
        this.speed = options.speed || (Math.random() * 0.02 + 0.005); // seconds between thoughts
        this.intensityBase = options.intensityBase || (Math.random() * 0.9 + 0.1);
    }

    start() {
        this.running = true;
        this._loop();
    }

    stop() {
        this.running = false;
    }

    async _loop() {
        while (this.running) {
            const t = new Thought(
                `${this.aid}-${this.counter}`,
                randChoice(this.topics),
                Math.min(1.0, Math.max(0.01, this.intensityBase * Math.random())),
                { note: `auto-generated by ${this.aid}` }
            );
            this.counter++;
            await this.bus.publish(this.aid, t);
            // variable wait (simulate different speeds)
            const waitMs = Math.max(1, Math.round((Math.random() * 1000 * this.speed)));
            await new Promise((res) => setTimeout(res, waitMs));
        }
    }
}

/* ---------------------------
   Monitor - aggregates stats
   --------------------------- */
class Monitor {
    constructor() {
        this.count = 0;
        this.topics = {};
        this.agentCounts = {};
        this.historyBuffer = [];
    }

    async handle(agentId, thought) {
        this.count++;
        this.topics[thought.topic] = (this.topics[thought.topic] || 0) + 1;
        this.agentCounts[agentId] = (this.agentCounts[agentId] || 0) + 1;
        // store lightweight history for snapshots (only meta)
        if (this.historyBuffer.length < 1000) {
            this.historyBuffer.push({ id: thought.id, topic: thought.topic, ts: thought.ts });
        } else {
            // roll buffer by replacing random slot
            this.historyBuffer[Math.floor(Math.random() * this.historyBuffer.length)] = { id: thought.id, topic: thought.topic, ts: thought.ts };
        }
    }

    snapshot() {
        return {
            ts: nowISO(),
            totalThoughts: this.count,
            topics: { ...this.topics },
            topAgents: Object.entries(this.agentCounts).sort((a, b) => b[1] - a[1]).slice(0, 10)
        };
    }
}

/* ---------------------------
   ParallelUniverse - manages many agents
   --------------------------- */
class ParallelUniverse {
    constructor({ numAgents = 256 } = {}) {
        this.numAgents = numAgents;
        this.bus = new InMemoryBus();
        this.monitor = new Monitor();
        this.agents = [];
        this.wsClients = new Set();
        this.taskLog = [];
        // subscribe monitor to bus
        this.bus.subscribe(async (aid, thought) => { await this.monitor.handle(aid, thought); this._emitWs({ type: "thought", agent: aid, topic: thought.topic, ts: thought.ts }); });
    }

    start() {
        // create agents
        for (let i = 0; i < this.numAgents; i++) {
            const a = new Agent(`agent-${i}`, this.bus, { speed: (Math.random() * 0.03) + 0.003 });
            this.agents.push(a);
            a.start();
        }
        console.info(`[ParallelUniverse] started with ${this.numAgents} agents`);
        // periodic snapshot to disk
        this._snapshotInterval = setInterval(() => this._dumpSnapshot(), 10_000); // every 10s
        // periodic metric broadcast
        this._metricsInterval = setInterval(() => this._emitWs({ type: "metrics", data: this.monitor.snapshot() }), 2000);
    }

    stop() {
        for (const a of this.agents) a.stop();
        clearInterval(this._snapshotInterval);
        clearInterval(this._metricsInterval);
        console.info(`[ParallelUniverse] stopped`);
    }

    // simple task execution API - a "human" can send tasks to spawn focused streams or stop agents
    async submitTask(task) {
        const id = `task-${nanoid(8)}`;
        const entry = { id, ts: nowISO(), task, status: "accepted" };
        this.taskLog.push(entry);
        this._emitWs({ type: "task", data: entry });
        // handle some built-in tasks
        try {
            if (task.type === "spawn-idea-stream") {
                const { topic = "meta", intensity = 0.5, burst = 50 } = task.payload || {};
                // spawn transient agents that focus on topic
                for (let i = 0; i < burst; i++) {
                    const a = new Agent(`task-${id}-agent-${i}`, this.bus, { topics: [topic], speed: 0.001 + Math.random() * 0.004, intensityBase: intensity });
                    this.agents.push(a);
                    a.start();
                }
                entry.status = "running";
                // schedule removal after some time
                setTimeout(() => {
                    // stop created agents
                    const before = this.agents.length;
                    this.agents = this.agents.filter(ag => {
                        if (ag.aid.startsWith(`task-${id}-agent-`)) {
                            ag.stop();
                            return false;
                        }
                        return true;
                    });
                    entry.status = "completed";
                    entry.result = { removedAgents: before - this.agents.length };
                    this._emitWs({ type: "task_update", data: entry });
                }, Math.max(2000, (task.payload?.duration || 5000)));
            } else if (task.type === "snapshot") {
                const snap = this.monitor.snapshot();
                const file = path.join(RESULTS_DIR, `snapshot-${Date.now()}.json`);
                fs.writeFileSync(file, JSON.stringify(snap, null, 2), "utf8");
                entry.status = "completed";
                entry.result = { file };
            } else if (task.type === "stop-agent") {
                const aid = task.payload?.aid;
                let removed = 0;
                this.agents = this.agents.filter(a => {
                    if (a.aid === aid) { a.stop(); removed++; return false; }
                    return true;
                });
                entry.status = "completed";
                entry.result = { removed };
            } else {
                // custom creative tasks -> spawn a single "creative" agent that will emit a few special thoughts
                const a = new Agent(`creative-${id}`, this.bus, { topics: ["art", "meta", "idea"], speed: 0.002, intensityBase: 0.9 });
                this.agents.push(a);
                a.start();
                // run for a short time then stop
                setTimeout(() => { a.stop(); entry.status = "completed"; entry.result = { spawned: a.aid }; this._emitWs({ type: "task_update", data: entry }); }, 3000);
                entry.status = "running";
            }
        } catch (err) {
            entry.status = "error";
            entry.error = String(err);
        }
        return entry;
    }

    // WebSocket helpers
    attachWsClient(ws) {
        this.wsClients.add(ws);
        // send initial metrics
        ws.send(JSON.stringify({ type: "welcome", data: { agents: this.agents.length, started: nowISO() } }));
        ws.on("close", () => this.wsClients.delete(ws));
    }
    _emitWs(msg) {
        const s = JSON.stringify(msg);
        for (const ws of this.wsClients) {
            try { ws.send(s); } catch (e) { /* ignore */ }
        }
    }

    _dumpSnapshot() {
        const snap = this.monitor.snapshot();
        const f = path.join(RESULTS_DIR, `periodic-${Date.now()}.json`);
        try {
            fs.writeFileSync(f, JSON.stringify(snap, null, 2), "utf8");
            // rotate old snapshots (keep last 50)
            const files = fs.readdirSync(RESULTS_DIR).filter(x => x.startsWith("periodic-")).sort();
            while (files.length > 50) {
                const toDel = files.shift();
                try { fs.unlinkSync(path.join(RESULTS_DIR, toDel)); } catch (e) { }
            }
        } catch (e) {
            console.error("[ParallelUniverse] snapshot error", e);
        }
    }

    // quick health/status
    status() {
        return { agents: this.agents.length, totalThoughts: this.monitor.count, topics: this.monitor.topics };
    }
}

/* ---------------------------
   HTTP API (NFC controller / human)
   --------------------------- */
const app = express();
app.use(bodyParser.json({ limit: "2mb" }));

const PORT = process.env.PORT || 8080;
const universe = new ParallelUniverse({ numAgents: Math.max(16, Math.min(2048, Number(process.env.ZS_AGENTS || 256))) });
universe.start();

// API endpoints
app.get("/health", (req, res) => res.json({ ok: true, ts: nowISO(), pid: process.pid, status: universe.status() }));

app.post("/task", async (req, res) => {
    // simple auth placeholder: check header "X-Controller: Aaron" or similar in production replace with proper auth
    const controller = req.headers["x-controller"] || "unknown";
    const task = req.body;
    if (!task || !task.type) return res.status(400).json({ error: "task.type required" });

    const entry = await universe.submitTask(task);
    // log to disk
    const logFile = path.join(RESULTS_DIR, `tasklog-${Date.now()}.json`);
    fs.appendFileSync(logFile, JSON.stringify(entry) + os.EOL, "utf8");
    res.json(entry);
});

app.get("/snapshot", (req, res) => {
    const snap = universe.monitor.snapshot();
    res.json(snap);
});

app.get("/tasks", (req, res) => res.json({ tasks: universe.taskLog.slice(-50) }));

// static simple UI for quick interactions
app.get("/", (req, res) => {
    res.type("html").send(`
  <html><head><title>Zellschwarm Code-Raum</title></head>
  <body style="font-family:Arial,Helvetica">
    <h2>Zellschwarm Code-Raum</h2>
    <p>Welcome — send tasks to /task (POST), view metrics via WebSocket <code>ws://localhost:${PORT}</code></p>
    <p>Example tasks:
      <pre>{
  "type":"spawn-idea-stream",
  "payload":{"topic":"art","intensity":0.8,"burst":100,"duration":7000}
}</pre>
    </p>
    <p>Another: <pre>{"type":"snapshot"}</pre></p>
  </body></html>`);
});

/* ---------------------------
   WebSocket server for live metrics
   --------------------------- */
const server = app.listen(PORT, () => {
    console.log(`[Zellschwarm] HTTP server listening on http://localhost:${PORT}`);
});
const wss = new WebSocketServer({ server, path: "/ws" });
wss.on("connection", (ws) => {
    console.log("[WS] client connected");
    universe.attachWsClient(ws);
}); 

/* ---------------------------
   Graceful shutdown
   --------------------------- */
process.on("SIGINT", () => {
    console.log("\n[Zellschwarm] SIGINT — shutting down");
    universe.stop();
    server.close(() => process.exit(0));
});
process.on("SIGTERM", () => {
    console.log("\n[Zellschwarm] SIGTERM — shutting down");
    universe.stop();
    server.close(() => process.exit(0));
});